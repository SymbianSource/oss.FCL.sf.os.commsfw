UTrace Decoder v1.01 (2008-01-18)
=====================================================

The UTrace decoder is a tool to translate the binary logs generated by the
ulogger into something that is both readable by humans and simpler to post
process with something like perl to generate other useful debugging
information. It is intended to be able to decode many different traced events
not just those related to the mesh machine, although it has specific
enhancements for that purpose.


1. Building the Code
-----------------------------------
In order to maintain the decoder you will need to have either MS VC++ 6 or MS
VC++ 2005 Express installed. Other compilers may work but I haven't tried any
others and you'll have to create your own makefiles/projects/solutions.

It "should" be a matter of loading the appropriate .dsw or .sln file and
hitting F7 to build.


2) Producing the log file
-----------------------------------
You'll need to use the version of utrace from the TVK v1.0_012. This was last
seen hiding out in \\builds01\dpbuilds\TVKv1.0_012.

Extract the zip and copy the extracted epoc32 tree over the top of the epoc32
directory in your current environment. Replace any conflicting files.

In eshell before running your test enable any utrace filters that you need and
run ulogger. You will need at least filters 194 and 195 enabled, but it is
recommended that you also enable filter 3 that additionally logs thread
information. For general text logging (used for esock logging) enable filter
196.
 

In eshell start a new eshell. If the code you run hangs you will need a way to
stop ulogger (which is the only way I know of to flush the log file).

> start eshell

To enable the filters and run ulogger use:

> ulogger -efv 194 195 3 196
> ulogger -rv

Option 'e' means enable, 'f' means filter, 'v' is verbose (the only way to know
if it worked) the rest is the space delimited list of filters to operate on.
You can use 'd' in place of 'e' to disable the filters.

In the first eshell run your code/test.

Once you are ready stop the ulogger.

> ulogger -qv

You should have a fairly substantial log file created in the epoc c:\logs


3) Decoding the binary log file
-----------------------------------
In a DOS window run
> utracedecoder --message-def {message_definition_file} ulogger.log > log.txt

The message definition file will be specific to your use of node messages and 
the mesh machine, although the core messages are defined in
nodemessages.definition.txt. You should include this file from your definition
file. The syntax of this file will be described later.


4) Getting the SVG diagram
-----------------------------------
Run parseit.bat (from comms-infras/elements/tools/svg) specifying the path to
the generated log.txt file.

> parseit.bat /log M:\path_to_log_file\log.txt


5) Message definition files
-----------------------------------
The message definition files are a special part of the decoder and only apply
to its use when dealing with node messages and the mesh machine. The file is
used to define the messages, signatures and run times contexts used to address
the messages.

The parser for these definition files is insensitive.
5.1) Comments
At present only c-style single line comments are supported. Support for
multi-line comments may be added later.

5.2) Numbers
Numbers are acceptable as either hex or decimal, with hex numbers being
prefixed with 0x.

5.3) Identifiers
Identifiers must start with a letter, but can otherwise contain numbers and
underscores. Identifiers can't be the same as any of the keywords or built in
type identifiers.

5.4) Built-in types
Built in types are:
UINT8   - Unsigned 8-bit number
UINT16  - Unsigned 16-bit number
UINT32  - Unsigned 32-bit number
INT8    - Signed 8-bit number
INT16   - Signed 16-bit number
INT32   - Signed 32-bit number
PAD     - Insert padding bytes into structures
TMESSAGEID - A built-in struct that represents a message realm and id.

Integer types can be given an optional modifier to identify how you would prefer
the number to be output. The default is HEX. 

PAD is treated as a byte, but is unnamed and never output. Unlike other types
PAD isn't followed by an identifier, but by a number indicating the number of
bytes to PAD by.
          
UINT32  [ HEX | DECIMAL ] {identifier}
PAD     {hex number} | {dec number}

5.5) Constants
Constants with the CONST. When the value is output it will be output as a
number.

CONST   {identifier} = {hex number} | {dec number}

5.6) Enumerations
Enumerations have a base type which must be one of the UINT/INT types. If
no base type is specified UINT32 is assumed. The purpose of the base type
is to enanble the decoder to know exactly how many bytes to use when
outputting the enum. If a named value cannot be found in the enum it will be
output as the integer base type. Enums can be given an optional modifier to
identify how you would prefer the number to be output if a named value cannot be
found. The default is HEX. 

ENUM  [ HEX | DECIMAL ] {identifier} [: {base type}]
    {identifier} = {hex number} | {dec number} 
    ...
END ENUM

5.7) Structures
Nothing very interest about structs. Each member of the struct will be output
on the same line as:
[{identifier}={value from log}].

Structures can be nested and when they are output they would look like:
[{identifier}=[{nested struct identifier}={value from log}] ]

STRUCT  {identifier}
    {type} {identifier}
    ...
END STRUCT

5.8) Signatures
Signatures define the structure of the messages that can be sent or received.

SIGNATURE {identifier} [: {signature}]
    TYPEID = {hex number} | {dec number} | {constant} : {hex number}
        | {dec number} | {constant}
    {type} {identifier}
    ...
END SIGNATURE

The best way to write these signatures is to start from the attribute table of
the signature.

EXPORT_START_ATTRIBUTE_TABLE_AND_FN(TSigStateChange, KNodeMessagesImplementationUid, ESignatureStateChange)
	REGISTER_ATTRIBUTE(TSigStateChange, iStateChange, TMeta<TStateChange>)
END_ATTRIBUTE_TABLE_BASE(TSignatureBase, ESignatureBase)

For example, to convert the attribute table above into a signature definition:
i.      Take the implementation uid from the first line and make a CONST for it

ii.     Take the signature Id from the first line and make an enumeration for
        it (since you will have many of these).

iii.    Create any structs you need to represent the registered attributes.
        STRUCT TStateChange
	        INT32 iStage
	        INT32 iError    
        END STRUCT

iv.     Write the signature
        SIGNATURE TSigStateChange : TSignatureBase
            TYPEID = KNodeMessagesImplementationUid:ESignatureStateChange
            TStateChange iStateChange
        END SIGNATURE

5.9) Messages
Message definitions tell the decoder which signature to use to display the
message data when it is found in the log. If no message definition can be
found the only information that will be presented in the output is the
STypeId of the signature.

MESSAGE {identifier}
    SIGNATURE = {signature}
    MESSAGEID = {hex number} | {dec number} | {constant} : {hex number} | {dec number} | {constant}
END MESSAGE

The best way to write the message definition is to start from the typedef of
the message.

typedef TMessageSigStateChange<EStateChange, TNodeMessage::ERealmId> TStateChange;

For the message typedef above:
i.      Define a CONST for the message realm id
ii.     Add the message id to an enumeration for the messages
iii.    Make sure your signature is defined
iv.     Write the message definition. Note that the T prefix is removed from
        the message name. This makes the logs clearer and avoids conflicts with
        the other identifiers that are related to it.
        MESSAGE StateChange
            SIGNATURE = TSigStateChange
            MESSAGEID = KNodeMessagesRealmId:EStateChange
        END MESSAGE

5.10) Contexts
The context definitions are used to output enough information for a sender or
receiver of a message to be identified. These are a little special in that it
is very important to get the size correct since contexts are identified through
their size. Context definitions can have other contexts as their base type.
Defining contexts with the same size as another context is not allowed.

CONTEXT {identifier} [: {context}]
    {type} {identifier}
    ...
END CONTEXT

5.11) Testing your definition file
To test your definition file use:
> utracedecoder --message-def {message_definition_file} --test-message-def

If there are any errors in the definition file they will be output. If all is
good there will no output.

5.12) Suspect data in you output?
If you think that there is garbage in the output from the decoder you can check
what the decoder thinks it got from your definition file. Run
> utracedecoder --message-def {message_definition_file} --test-message-def
    --dump-message-def > debug.txt

You'll see a bunch of output, most of it straight forward.
In the description of structs/contexts/signatures the number before the
colon is the offset from the base of that structure.

Another way to investigate the suspect data is to dump the frames that make up
the event. Using the frame numbers from the output you can select frames to dump
during the decoding.

Note that the output may appear to skip frames numbers. This is because only the
frame number of the first frame of a multi frame event is output.

To dump the frames use the --dump-frame command line option. The frames will be
dumped to stderr.

> utracedecoder --message-def {message_definition_file}
    --dump-frame {start_frame},{end_frame} ulogger.log > log.txt

Alternatively use the --dump-event command line option. Any multi part frames
will be dumped after they have been recombined. The event numbers use the same
sequence numbers as the frames.

> utracedecoder --message-def {message_definition_file}
    --dump-event {start_event},{end_event} ulogger.log > log.txt
